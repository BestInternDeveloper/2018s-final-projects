# 确定性抽象解释器

## 背景

refinement.js(rfjs) 是 xWIDL 的一个实现方法，它的原理是将断言语言编译为会触发平凡的错误（如空指针异常）的 JavaScript 代码，交给静态分析器去分析。rfjs 通过调用静态分析器得到错误报告，并对错误报告进行理解和转化，并呈现给用户。经过推理和实验验证（见 report.md），rfjs 的效果好于原 Dafny 的方案。

但是在开发 rfjs 的过程中也碰到了很多问题。一是敏感度的问题，为了让分析器能追踪错误产生的地方，我设计一些包装函数，如 __rfjs_wrap 函数。这些函数可以帮助我们在不用拿到 CFG 的情况下对原问题进行编码。但是，一个显著的问题是，我们的包装函数在代码中多次出现，给 CFG 增加了很多意义不大的节点，这对分析器造成了负担。TAJS 的做法似乎是知难而退，增加了这些节点导致的结果不是分析时间变长，而是分析精度变低，一些很简单的样例代码都难以分析出正确的结果。在查了 TAJS 的文档之后，我发现 TAJS 提供了很多内置函数，可以让我们认为控制函数、参数、对象的敏感度，敏感度越高，分析越精确。于是，在经过一些我称之为“调参”的尝试之后，rfjs 的分析精度得到了提高。但在这个过程中我发现，TAJS 提供的内置函数不好用，有的函数功能有重叠，表达的语义有限且模糊。于是在使用这些内置函数时，要么想表达的语义无法表达，要么得到的结果完全不可预测。二是调用栈问题，程序分析器在分析时只会告诉你哪些地方出错了，但不会告诉你造成这个错误的上下文和调用栈。


因此，我想做一些关于确定性抽象解释器的探索，看看能不能定义并实现一个确定性的抽象解释器。

## 初步的想法

* 抽象域要可以选择
* 只要是代码块都要可以引用
* 一套代码，两套语义

简单的例子：
```python
a = input()
b = input()
if a>1 and b<0:
    c = a*4-b
else:
    c = b
```
在 Python 解释器中，上述代码的语义是：输入两个数 a,b，如果 a>1 并且 b<0，则 c = a*4 - b，否则，c = b

在抽象解释器中，若采用不相关的集合抽象域（只考虑整数），a = input() 的语义是 a 的抽象域初值为全集，如果在 if 处敏感，那么 c 的抽象域是 (a>1 and b<0) => {c|c>4} /\ (a<=1 or b>=0) => {c|c>=0}，如果对这个 if 不敏感，那么结果是 {c|c>=0}。

抽象域的选择有很多种，即我们需要一种范式来表达集合，比如区间，比如差分约束系统，比如不等式等等。敏感度的选择也是很重要的，什么地方的值需要 join，什么地方不需要，什么地方需要考虑调用环境，什么地方不需要等等问题都是。这些“参数”在通常的程序分析器中都是由设计者根据实验结果来调整的，这种调整与分析器代码高度相关，既不能发挥程序员的作用，也不能借助机器学习来调参。
